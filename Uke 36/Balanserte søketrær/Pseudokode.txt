*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
Algoritme for Høyre-Rotasjon av et Binærtre
Input: En node "v"
Output: Roter treet til høyre slik at "y" blir den nye roten
-------------------
Procedure RightRotate(z):
    y <- z.left
    T2 <- y.right
    y.right <- z
    z.left <- T2
    z.height <- 1 + max(Height(z.left), Height(z.right))
    y.height <- 1 + max(Height(y.left), Height(y.right))
    return y

*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
Algoritme for Venstre-Rotasjon av et Binærtre
Input: En node "v"
Output: Roter treet til venstre slik at "y" blir den nye roten
-------------------
Procedure LeftRotate(z):
    y <- z.right
    T1 <- y.left
    y.left <- z
    z.right <- T1
    z.height <- 1 + max(Height(z.left), Height(z.right))
    y.height <- 1 + max(Height(y.left), Height(y.right))
    return y

*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
Algoritme for å finne balansefaktoren av en node
Input: En node "v"
Output: Returnerer høydeforskjellen mellom "v" sitt venstre- og høyrebarn
Kjøretid: O(1), siden vi kun henter høydeforskjellen mellom to verdier
-------------------
Procedure Balancefactor(v):
    if v == null then
        return 0
    return height(v.left) - height(v.right)

*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
Algoritme for balansering av et AVL-tre:
Input: En node "v"
Output: En balansert node
Kjøretid: O(log(n)) siden vi fjerner løvnode fra en gitt subtre, trenger ikke å traverse gjennom hele treet 
-------------------
Procedure Balance(v):
    if Balancefactor(v) < -1 then
        if Balancefactor(v.right) > 0 then
            v.right = RightRotate(v.right)
        return LeftRotate(v)
    if Balancefactor(v) > 1 then
        if Balancefactor(v.left) < 0 then
            v.left = LeftRotate(v.left)
        return RightRotate(v)
    return v

*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
Algoritme for innsetting i et AVL-tre
Input: En node "v" og et element "x"
Output: En oppdatert node "v" der en node som inneholder "x" er en etterkommer av "v"
Kjøretid: O(log(n))
-------------------
Procedure Insert(v,x):
    if v == null then
        v <- new Node(x)
    else if x < v.element then
        v.left <- Insert(v.left, x)
    else if x > v.element then
        v.right <- Insert(v.right,x)
    v.height <- 1 + max(Height(v.left), Height(v.right))
    return Balance(v)

*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
Algoritme for å sletting av node i AVL-tre:
Input: En node "v" og et element "x"
Output: Dersom "x" forekommer i en node "u" som en etterkommer av "v", fjern "u".
Kjøretid: O(log(n)) siden vi kun iterer i venstre subtre
-------------------
Procedure Remove(v):
    if v == null then
        return null
    if x < v.element then
        v.left <- Remove(v.left, x)
    else if x > v.element then
        v.right <- Remove(v.right, x)
    else if v.left = null then
        v <- v.right
    else if v.right = null then
        v <- v.left
    else 
        u <- FindMin(v.right)
        v.element <- u.element 
        v.right <- Remove(v.right, u.element)
    v.height <- 1 + max(Height(v.left), Height(v.right))
    return Balance(v)