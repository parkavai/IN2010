Uvektede grafer: BFS

Vektede, rettede grafer
    - kanter med kun positiv vekt: Dijkstra
    - kanter med både + og - vekt: Bellman-Ford

*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
Alg: Dijkstra algoritme
Input: En vektet, sammenhengende graf G, og en startnode s
Output: Liste med vekten av den korteste veien fra s til alle noder i G
-------------------
def Dijkstra(G, startNode):
    Q = new empty Heap
    for each node in G do:
        Distance[node] = infinite
        Q.insert(node, Distance[node])

    Distance[startNode] = 0
    while Q not empty do:
        node = Q.removeMin()
        
        for edge e = (node, t) in G do:
            if (Distance[node] + weight(e)) < Distance[t] then:
                Distance[t] = Distance[node] + weight(e)
                change value of t in Q to Distance[t]
        end
    end

    return D
-------------------
Ideen bak er et BFS som tar høyde for kantenes vekt
Analysen antar at
    1. Bruker naboliste representasjon av G
    2. Binær heap for Q

O((|V| + |E|)log(|V|))
 = O (|E| log(|V|))
-------------------

Analyse av Dijkstra
Ideen bak denne algoritmen er ganske lik Prim, men hvor vi nå benytter av prioritetskø. 
I denne køen så vil vi legge til noder og setter en infinite distanse som standardverdi. 
Deretter itererer vi igjennom hele heapen og popper av de minste nodene med lavest distanse. Videre 
itererer vi igjennom kanten som forbinder noden som ble poppet(u) og noden som (u) er bundet til som vi 
kan kalle (v). Tilslutt sammenligner vi distansen for den gitte noden med den helhetlige korteste 
distansen vi har foreløpig. Grunnen er for å oppdatere distansen skulle denne kanten ha en vekt som er lavere 
enn det vi har foreløpig. For poenget ved Dijkstra er å finne en distanse som tilsvarer da den korteste stien 
vi finner ved å traversere grafen. Derfor oppdateres distansen regelmessig ettersom vi skal overholde dette 
prinsippet. Tilslutt returnerer vi distansen "D".

For å oppsummere
Hensikten med Dijkstra er å finne den korteste stien ved å benytte vektene til kantene mellom noder. Vi er 
da ute etter den korteste stien i en sammenhengende graf. Algoritmen godtar ikke negative kanter, men det 
gjør BellmanFord algoritmen. Men som nevnt så er denne algoritmen ment for å finne den korteste stien i grafen 
hvor vi har en startnode vi starter fra og finner den korteste stien fra denne startnoden. 

*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
Alg: Bellman-Ford, finner korteste sti eller oppdager negative sykler
Input: En vektet, sammenhengende graf G, og en startnode s
Output: Liste med vekten av den korteste veien fra s til alle noder i G
-------------------
def BellmanFord(G, startNode):
    for each node in G do
        D[node] = infinite
    end

    D[startNode] = 0
    
    # oppdaterer estimert avstand D for alle noder, |V|−1 ganger
    for i from 1 to |V|−1 do:
        for edge (u,v) in G do:
            if (D[u] + weight(u, v)) < D[v] then:
                D[v] = D[u] + weight(u, v)
        end
    end

    # Om vi finner en kortere vei etter at vi egentlig er ferdig, så har vi funnet en negativ sykel
    for edge (u,v) in G do:
        if D[u] + weight((u, v)) < D[v] then:
            return “G has a negative cycle”
    end
    return D
-------------------
O(|V|·|E|)
Finner korteste sti eller oppdager negative sykler
-------------------
