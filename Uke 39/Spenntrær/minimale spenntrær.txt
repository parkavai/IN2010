Uvektede grafer, for å finne spenntre: DFS eller BFS

Vektede, sammenhengende grafer:
OBS! Det er ikke noe problem med negative vekter, iallefall for Prims og Kruskals. De velger den laveste
fra hepaen, og heapen behandler ikke negative tall annerledes. Man kan unngå hele problematikken med å bare
plusse et høyt tall på alle kant-vektene, siden det vi egentlig bryr oss om er å se på forskjellene på vektene
til de ulike kantene.

Grådige algoritmer:
Algoritmer hvor vi ikke backtracker. DFS er da et unntak
av dette.

Alle har: O(|E| * log(|V|))

*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
Alg: Prims algoritme, grådige noder
Input: En vektet, sammenhengende graf G
Output: Et minimalt spenntre for G
-------------------
def Prim(G):
    Tree = new empty Tree
    Q = new empty Heap #minimal Heap, (altså en priorityQueue)
    kostnad = []

    # Legger til alle vertex/noder, i en node som også har billigste kant til den fra spenntreet
    # De legges til sammen med kostnaden til å komme dit, og heapen sorterer dem etter denne
    for each vertex v in G do:
        kostnad[v] = infinite  #Alle starter med "uendelig" kostnad, denne skal senkes etterhvert
        n = (v, None)  #v er en vertex/node, og None er en kant fra treet til den
        Q.insert(n, kostnad[v])
    end

    # Velger en tilfeldig vertex/node å starte fra, og setter deres kostnad til å være 0
    # Da blir de første som plukkes ut av Q når vi går inn i while-løkken
    pick v from V
    set D[v] = 0

    while Q not empty do:
        (a, edge) = Q.removeMin() # Plukker ut noden som har lavest kostnad å komme seg til
        Tree.add(a, edge)         # Og legger den til i spenntreet vi bygger opp
        
        # Oppdaterer avstanden fra spenntreet vi bygger opp til alle noder som ikke er med i treet
        # Dvs. sjekk alle kanter ut fra noden a til en node b, der b enda ikke er plukket ut av Q
        for Edge e = (a, b) with b in Q do:
            if e.weight < kostnad[b] then:
                kostnad[b] = e.weight
                Change entry of b in Q to ((b, e), kostnad[b])
        end
    end
-------------------
O((|V|+|E|)log(|V|))
 = O(|E| * log(|V|))

Prim’s algorithm gives connected component as well as it works only on connected graph.
-------------------

Analyse av Prims algoritmer(grådige noder)
Prims algoritme benyttes for spenntrær hvor vi da traverserer gjennom vektede grafer 
etter de nodene som er billigst sammenhengende. Dvs at når vi har valgt en gitt node å traversere 
fra, så vil vi alltid bygge spenntreet fra denne noden. Det er viktig å ivareta en invariant ved spenntrær 
som er slik at vi ikke skal ha noen sykler i grafen. Prims algoritme sjekker dette tilfellet 
hvor de da unngår noder som er blitt lagt til spenntreet for å unngå sykler. Vi har en heap 
hvor vi da legger til alle noder som vi ikke har lagt til i treet. I tillegg har vi en distanse 
som oppdaterer den minste distansen mellom noder i den gitte grafen(kanten med billigst vekt). 
Når vi skal traversere gjennom heapen så skal vi da fjerne kanter som har billigst vekt og hente 
ut nodene for den kanten og legge den til i spenntreet. Deretter har vi en for-løkke hvor vi sjekker 
alle kanter fra noden "a" til noden "b", hvor node "b" ikke er blitt lagt enda. Grunnen er for å 
foreta en sjekk hvor vi sammenligner kanten sin vekt med kanten til node "b" sin vekt og sjekker om 
den er mindre. Skulle sjekket inntreffe så skal vi oppdatere distansen til å tilsvare den nye kanten med 
minst vekt, og endre stien hvor vi traverserer gjennom den nye noden og dets kant. 

For å oppsummere 
Prims algoritmen tar å traverserer gjennom alle noder i grafen og setter disse i en heap med vekten også. 
Deretter tar vi ut en tilfeldig node og setter distansen til å tilsvare 0 foreløpig. Deretter har vi en 
while-løkke hvor vi traverserer så lenge heapen ikke er tom og henter ut kanten med billigst vekt. Videre 
sjekker vi om vi har en kant som er billigere enn den noden vi nettopp poppet ut. Hvis sjekket inntreffer så 
skal vi da endret distansen til å tilsvare denne og endre stien hvor vi traverserer gjennom den nye noden og 
dets kant. 


*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
Alg: Kruskals algoritme, grådige kanter
Input: En vektet, sammenhengende graf G
Output: Et minimalt spenntre for G
-------------------
def Kruskal(Q):
    Tree = new empty Tree
    Q = new empty Heap

    for each edge e in G do:
        Q.insert(e)
    end

    for each vertex v in G do:
        define Cluster(v) = {v}
    end

    while Tree has fewer than n-1 edges do:
        (u, v) = Q.removeMin()

        # Om nodene u og v ikke allerede er en del av samme cluster,
        # dvs. kanten mellom dem er ikke lagt til i spenntreet vi bygger opp enda
        if Cluster(u) != Cluster(v) then:
            add (u, v) to Tree
            Cluster(u) = Combine(Cluster(u), Cluster(v))
            Cluster(v) = Combine(Cluster(u), Cluster(v))            
    end
    return T
-------------------
O(log(|E|)) er O(log(|V|^2))= O(2log(|V|))
 = O(|E| * log|V|)
Bedre for tynne grafer
Bedre om man allerede har kantene sortert etter vekt
Kruskal’s algorithm can generate forest(disconnected components) at any instant as well as it can work on disconnected components
-------------------

Analyse av Kruskal algoritmer(grådige kanter)
Kruskals algoritme er annerledes fra Prim ettersom kruskal letter etter de kantene som har billigst vekt.
Algoritmen er også annerledes i at vi bygger spenntreet gjennom å kombinere diverse kløsteret som består 
av kanter med billigst vekt imotsetning til prim hvor vi bygger den sammenhengende. Vi har da en heap hvor 
vi da setter inn kanter i grafen. Deretter traverserer vi gjennom hver node og lager et kløster som enhver node 
har hver for seg. Videre har vi en while-løkke som traverserer så lenge treet har færre enn (n-1 kanter) hvor 
vi skal da fjerne kanten som er billigst i heapen vår. Deretter bruker vi kløstrene som "u" og "v" er en del av 
til å sjekke om disse ikke er knyttet til hverandre. Hvis de ikke er knyttet til hverandre, så skal vi da legge til 
nodene i spenntreet og kombinere disse kløsterne sammen. 

For å oppsummere
I kruskals algoritme så har vi løkke hvor vi traverserer gjennom enhver kant i G og har en heap hvor vi 
legger til alle kanter hvor de billigste kantene tas ut først når vi skal bygge spenntreet. Vi har også en 
løkke hvor vi traverserer gjennom hver node i G og lager et kløster for enhver node. Tilslutt har vi en 
løkke hvor vi popper ut den kanten som er billigst i heapen og sammenligner kløstrene til begge nodene 
som var i kanten. Skulle ikke disse være like, så skal vi sette disse inn i treet og kombinerer disse kløstrene
sammen. 

*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
Alg: Boruvkas algoritme, grådige kanter
Input: En vektet, sammenhengende graf G
Output: Et minimalt spenntre for G
-------------------
def Boruvka(G):
    T = new empty Tree

    # Hver node starter som sin egen komponent
    for each vertex v in G do:
        add v to T
    end

    while T has more than one component do:
        # for hver komponent i treet
        for each component C in T do:
            # for hver node i komponenten
            for each vertex v in C do:
                # sett nodens komponent til å være C
                Comp(v) = C
            end
            cheapest(C) = None  # billigste kant ut fra denne komponenten
        end

        for each edge e=(u,v) in G do:
            if Comp(u) != Comp(v) then: #dvs. om kanten forbinder to ulike komponenter

                # Sjekker om denne edgen er billigere enn den nåværende billigste ut fra komponenten til u, w=weight
                if w(e) < w(cheapest(Comp(u))) then:
                    cheapest(Comp(u)) = e
                # Samme greia, men for komponenten til v
                if w(e) < w(cheapest(Comp(v))) then: #sjekker
                    cheapest(Comp(v)) = e
        end

        for each cheapest(C) != None do:
            add cheapest(C) to T
        end
    end
    return T
-------------------
O((|V| + |E|)log(|V|))
 = O(|E|log(|V|))

Parallelliserbar
-------------------

Analyse av Boruvka algoritmer(grådige kanter)
For denne algoritmen så vil vi lage komponenter av hver node og slå dem sammen med andre 
komponenter til å forme vårt spenntre. Dette gjøres ved å sammenligne de kantene som har 
billigst vekt til en gitt komponent og slår da disse sammen til å utgjøre et stort komponent. 
Dette gjøres helt til vi har lagd store separate komponenter hvor vi da slår sammen de resterende 
komponentene med hverandre. Så vi ser i algoritmen at vi lager en komponent for hver node og har en 
cheapest(C) som sier at vi skal hente den billigste kanten som går ut fra den komponenten. Deretter 
går vi gjennom alle kanter og sjekker om det finnes en kant som forbinder to forskjellige komponenter. 
Hvis vi finner en kant som gjør dette, så sammenligner vi vekten for den kanten og sammenligner det med 
begge komponentene sine cheapest(C) og må eventuelt ersatte cheapest(C) til å tilsvare denne billige kanten. 

For å oppsummere
I denne algoritmen så tildeler vi en komponent til hver node, samt en cheapest(C) som uttrykker den billigste 
vekten som går ut av denne komponenten. Deretter så traverserer vi gjennom hver kant i grafen og leter etter 
de billigste vektene som binder to forskjellige komponenter. Som nevnt så er vi ute etter de billigste vektene 
for cheapest(C) og derfor skal vi kun hente den billigste kanten som binder to forskjellige komponenter med 
hverandre. Deretter bygger vi spenntreet ved å legge til komponentene i treet gjennom cheapest(c). 
